# 对象的生命周期 p145

对象的生命周期从对象的 `构造函数完成`的那一刻开始，直到 `析构函数执行`为止。对于那些 `没有声明构造函数`的类型（比如 int），我们可以认为他们 `拥有默认的构造函数和析构函数`，并且 `两个函数不执行任何操作`。

根据 `对象的生命周期`把对象化分为 `5`类：

1.  **`自动（automatic）`** 对象：
    - 除非特别说明（2.1.8[局部变量](/)和 16.2.12[static 成员](/)），否则在 `函数中声明`的对象在其 `定义处被创建`，当 `超出作用范围时被销毁`。
    - 在大多数实现中，自动对象被分配在 `栈空间`上。
    - 每调用一次函数，获取新的 `帧栈（stack frame）`以存放它的自动对象。
2.  **`静态（static）`** 对象：
    - 在 `全局作用域`或 `名字空间作用域`（[6.3.4](/)）中生命的对象。
    - 在 `函数`（[12.1.8](/)）或 `类`（[16.2.12](/)）中声明的 `static成员`，只能 `被创建并初始化一次`，并且 `直到程序结束之前`都“活着”（[15.4.3](/)）。
    - 静态对象在程序的整个执行周期内 `地址唯一`。
    - 在多线程环境中，静态对象可能会造成意料之外的问题。以为 `所有线程都共享静态对象`，所以必须为其 **`加锁`**以避免数据竞争（[5.3.1](/)和[42.3](/)）。
3.  **`自由存储(free store)`** 对象：
    - 用 new 和 delete 直接控制其生命周期的对象。
4.  **`临时（temporary）`** 对象：
    - `计算用的中间结果`。
    - 用于 `存放const实参引用的值`的对象。
    - 临时对象的生命周期由其用法决定：
      - 如果临时对象 **`被绑定到一个引用`** 上，则它的生命周期就是 **`引用的生命周期`**；
      - **否则**，临时对象的生命周期与它 `所处的完整表达式一致`。
      - 其中，完整表达式（full expression）不属于任何其他表达式。
      - 通常情况下，_临时对象也是自动对象_。
5.  **`线程局部（thread_load）`** 对象，或者说声明为 `thread_load`（[42.2.8](/)）的对象：
    - 这样的对象**随着线程的创建而创建，随着线程的销毁而销毁**。

其中，`静态`和 `自动`对象被称为 `存储类（storage class）`。

`数组元素`和 `非静态成员`的生命周期由他们 `所属的对象决定`。
